{% extends 'base.html' %}
{% block content %}
<style>
.cutplanner-layout { margin: 0; font-family: Arial; display:flex; height:calc(100vh - 170px); }
#left { width:360px; background:#1b1b1b; color:#eee; padding:12px; overflow:auto; }
#main { flex:1; background:#000; position:relative; }
#main canvas { width:100%; height:100%; display:block; }
#imageMap { position:absolute; inset:0; pointer-events:auto; z-index:2; }
.part-hit { position:absolute; border:0; background:transparent; color:transparent; pointer-events:auto; cursor:pointer; }
#left button { cursor:pointer; }
.item { display:flex; align-items:center; gap:6px; padding:4px 0; border-bottom:1px solid #333; }
.small { font-size:12px; opacity:0.8; }
#left a { color:#9cf; }
</style>

<div class="cutplanner-layout">
  <div id="left">
    <h2 style="margin-top:0">{{job.name}}</h2>
    <div class="small">Job ID: {{job.id}}</div>
    <hr>

    <div style="display:flex; gap:8px; flex-wrap:wrap">
      <button onclick="showAll()">Show All</button>
      <button id="toggleContoursBtn" onclick="toggleContours()">Contours: On</button>
      <button id="panToggleBtn" onclick="togglePanMode()">Pan: Off</button>
      <button onclick="exportReorder()">Export Reordered</button>
      <button onclick="computeSkeleton()">Compute Skeleton Cuts</button>
    </div>
    <div style="margin-top:8px">
      <a id="dlRe" style="display:none">Download reordered</a><br>
      <a id="dlSk" style="display:none">Download skeleton</a>
    </div>

    <h3>Parts (top → bottom)</h3>
    <div id="partsList"></div>

    <h3>Contours (global order)</h3>
    <div id="list"></div>

    <hr>
    <div class="small">Click a part frame on the drawing (image-map hit area) to focus it. Skeleton cuts render in red.</div>
  </div>

  <div id="main">
    <canvas id="cv"></canvas>
    <div id="imageMap"></div>
  </div>
</div>

<script>
const jobId = {{job.id}};
const cv = document.getElementById("cv");
const ctx = cv.getContext("2d");
function resize(){ cv.width = cv.clientWidth; cv.height = cv.clientHeight; draw(); }
window.addEventListener("resize", resize);
let model = null;
let currentPart = null;
let order = [];
let baseScale = 1;
let zoom = 1;
let panX = 0;
let panY = 0;
let showContours = true;
let panMode = false;
let draggingPan = false;
let dragStart = null;
let drawParts = [];
let partOrder = [];
let contourBlocks = [];
function fitView(){
  if(!model) return;
  const sheet = model.sheet; const pad = 60;
  baseScale = Math.min((cv.width - pad*2)/(sheet.width||1), (cv.height - pad*2)/(sheet.height||1));
  zoom = 1;
  panX = pad;
  panY = pad;
}
function flattenContours(m){ const out=[]; m.parts.forEach((p, pi)=>p.contours.forEach(c=>out.push({partIndex:pi, part:p, contour:c}))); return out; }
function initOrder(){
  const blockRows = new Map();
  flattenContours(model).forEach((row) => {
    const blockId = row.contour.block_id ?? row.contour.id;
    if(!blockRows.has(blockId)) blockRows.set(blockId, []);
    blockRows.get(blockId).push(row);
  });
  contourBlocks = [...blockRows.entries()].sort((a,b)=>a[0]-b[0]).map(([blockId, rows]) => ({blockId, rows}));
  order = contourBlocks.map((b) => b.blockId);
}
function getPartBounds(part){
  const points = [];
  part.contours.forEach(c=>c.segments.forEach(s=>{
    if(s.kind === "line"){ points.push(s.a, s.b); }
    if(s.kind === "polyline"){ points.push(...s.points); }
  }));
  if(!points.length) return null;
  const xs = points.map(p=>p[0]), ys = points.map(p=>p[1]);
  return {minX:Math.min(...xs), maxX:Math.max(...xs), minY:Math.min(...ys), maxY:Math.max(...ys)};
}
function sortPartsTopToBottom(){
  drawParts = model.parts.map((part, idx) => ({idx, part, bounds:getPartBounds(part)}));
  drawParts.sort((a,b)=>{
    const ay = a.bounds ? (a.bounds.maxY + a.bounds.minY)/2 : -Infinity;
    const by = b.bounds ? (b.bounds.maxY + b.bounds.minY)/2 : -Infinity;
    return by - ay;
  });
  drawParts.forEach((row, i)=>{ row.displayIndex = i + 1; });
  partOrder = drawParts.map((row) => row.idx);
}
function syncPartDisplayIndices(){
  const orderRank = new Map(partOrder.map((partIdx, idx) => [partIdx, idx + 1]));
  drawParts.forEach((row) => {
    row.displayIndex = orderRank.get(row.idx) ?? row.displayIndex;
  });
}
function rebuildContourOrderFromPartOrder(){
  syncPartDisplayIndices();
  const partRank = new Map(partOrder.map((partIdx, rank) => [partIdx, rank]));
  contourBlocks.sort((a, b) => {
    const aRow = a.rows[0];
    const bRow = b.rows[0];
    const aRank = partRank.get(aRow?.partIndex) ?? Number.MAX_SAFE_INTEGER;
    const bRank = partRank.get(bRow?.partIndex) ?? Number.MAX_SAFE_INTEGER;
    if(aRank !== bRank) return aRank - bRank;
    const aContour = aRow?.contour?.index ?? aRow?.contour?.id ?? Number.MAX_SAFE_INTEGER;
    const bContour = bRow?.contour?.index ?? bRow?.contour?.id ?? Number.MAX_SAFE_INTEGER;
    if(aContour !== bContour) return aContour - bContour;
    return a.blockId - b.blockId;
  });
  order = contourBlocks.map((b) => b.blockId);
}
function renderList(){
  const list = document.getElementById("list"); list.innerHTML = "";
  const byBlock = new Map(contourBlocks.map(x => [x.blockId, x.rows]));
  const displayByPart = new Map(drawParts.map(r => [r.idx, r.displayIndex]));
  order.forEach((blockId, idx) => {
    const rows = byBlock.get(blockId); if(!rows?.length) return;
    const row = rows[0];
    const div = document.createElement("div"); div.className = "item";
    const partNum = displayByPart.get(row.partIndex) ?? "?";
    div.innerHTML = `<div style="width:34px; text-align:right; opacity:0.7">${idx+1}</div><div style="flex:1"><div>P${partNum}-C${row.contour.index ?? "?"} <span class="small">(${row.contour.type})</span></div><div class="small">prog ${row.part.program_id ?? "?"} contours ${row.part.contour_count ?? "?"}</div></div><button ${idx===0?"disabled":""} onclick="moveUp(${idx})">↑</button><button ${idx===order.length-1?"disabled":""} onclick="moveDown(${idx})">↓</button>`;
    list.appendChild(div);
  });
}
function renderPartsList(){
  const node = document.getElementById("partsList");
  node.innerHTML = "";
  const byPart = new Map(drawParts.map((row) => [row.idx, row]));
  partOrder.forEach((partIdx, idx) => {
    const row = byPart.get(partIdx);
    if(!row) return;
    const div = document.createElement("div");
    div.className = "item";
    const programLabel = row.part.program_id ? `N${row.part.program_id}` : "?";
    const firstContour = row.part.first_contour_id ?? "?";
    div.innerHTML = `<button onclick="focusPart(${row.idx})">Part ${idx + 1}</button><div class="small" style="margin-left:auto">prog ${programLabel} / first contour ${firstContour} / contours ${row.part.contour_count ?? "?"}</div><button ${idx===0?"disabled":""} onclick="movePartUp(${idx})">↑</button><button ${idx===partOrder.length-1?"disabled":""} onclick="movePartDown(${idx})">↓</button>`;
    node.appendChild(div);
  });
}
function movePartUp(i){
  [partOrder[i-1], partOrder[i]] = [partOrder[i], partOrder[i-1]];
  rebuildContourOrderFromPartOrder();
  renderPartsList();
  renderList();
  draw();
}
function movePartDown(i){
  [partOrder[i], partOrder[i+1]] = [partOrder[i+1], partOrder[i]];
  rebuildContourOrderFromPartOrder();
  renderPartsList();
  renderList();
  draw();
}
function moveUp(i){ [order[i-1], order[i]] = [order[i], order[i-1]]; renderList(); draw(); }
function moveDown(i){ [order[i], order[i+1]] = [order[i+1], order[i]]; renderList(); draw(); }
function showAll(){ currentPart = null; draw(); }
function focusPart(partIndex){ currentPart = partIndex; draw(); }
function toggleContours(){ showContours = !showContours; document.getElementById("toggleContoursBtn").textContent = `Contours: ${showContours ? "On" : "Off"}`; draw(); }
function togglePanMode(){
  panMode = !panMode;
  document.getElementById("panToggleBtn").textContent = panMode ? "Pan: On" : "Pan: Off";
  cv.style.cursor = panMode ? "grab" : "default";
}
async function exportReorder(){
  const r = await fetch(`/api/cutplan/${jobId}/reorder`, {method:"POST", headers:{"Content-Type":"application/json"}, body:JSON.stringify({order})});
  const j = await r.json(); if(j.download){ const a = document.getElementById("dlRe"); a.href = j.download; a.textContent = "Download reordered MPF"; a.style.display = "inline"; }
}
async function computeSkeleton(){
  const r = await fetch(`/api/cutplan/${jobId}/compute_skeleton`, {method:"POST"});
  const j = await r.json(); if(j.download){ const a = document.getElementById("dlSk"); a.href = j.download; a.textContent = "Download skeleton MPF"; a.style.display = "inline"; }
  location.reload();
}
function worldToCanvas(p){ const scale = baseScale * zoom; return [p[0]*scale + panX, cv.height - (p[1]*scale + panY)]; }
function canvasToWorld(x, y){ const scale = baseScale * zoom; return [(x - panX)/scale, ((cv.height - y) - panY)/scale]; }
function draw(){
  if(!model) return;
  ctx.clearRect(0,0,cv.width,cv.height);
  const sheet = model.sheet;
  const scale = baseScale * zoom;
  ctx.strokeStyle="#444"; ctx.lineWidth=2; ctx.strokeRect(panX, cv.height-(sheet.height*scale+panY), sheet.width*scale, sheet.height*scale);
  const byBlock = new Map(contourBlocks.map(x => [x.blockId, x.rows]));
  const displayByPart = new Map(drawParts.map(r => [r.idx, r.displayIndex]));
  const imageMap = document.getElementById("imageMap");
  imageMap.innerHTML = "";

  drawParts.forEach(row => {
    const hitAreas = [];
    const frames = row.part.frames || [];
    frames.forEach(f => {
      const [ox, oy] = f.origin || [0,0];
      const [fx, fy] = f.dims || [0,0];
      if(fx <= 0 || fy <= 0) return;
      hitAreas.push({minX: ox, minY: oy, maxX: ox + fx, maxY: oy + fy});
    });
    if(!hitAreas.length && row.bounds){
      hitAreas.push(row.bounds);
    }
    hitAreas.forEach((area) => {
      const a = worldToCanvas([area.minX, area.minY]);
      const b = worldToCanvas([area.maxX, area.maxY]);
      const left = Math.min(a[0], b[0]);
      const top = Math.min(a[1], b[1]);
      const width = Math.abs(a[0] - b[0]);
      const height = Math.abs(a[1] - b[1]);

      const hit = document.createElement("button");
      hit.className = "part-hit";
      hit.style.left = `${left}px`;
      hit.style.top = `${top}px`;
      hit.style.width = `${Math.max(width, 8)}px`;
      hit.style.height = `${Math.max(height, 8)}px`;
      hit.title = `Part ${row.displayIndex}`;
      hit.setAttribute("aria-label", `Part ${row.displayIndex}`);
      hit.onclick = () => focusPart(row.idx);
      imageMap.appendChild(hit);
    });
  });

  if(showContours){
  order.forEach((blockId) => {
    const rows = byBlock.get(blockId) || [];
    rows.forEach((row) => {
      if(currentPart !== null && row.partIndex !== currentPart) return;
      const c = row.contour; const hue = (row.partIndex * 70) % 360;
      if(c.type === "outer"){ ctx.strokeStyle = `hsl(${hue},80%,60%)`; ctx.lineWidth = 3; } else { ctx.strokeStyle = "#00ffff"; ctx.lineWidth = 2; }
      ctx.beginPath();
      c.segments.forEach(s => { if(s.kind === "line"){ const a=worldToCanvas(s.a), b=worldToCanvas(s.b); ctx.moveTo(a[0], a[1]); ctx.lineTo(b[0], b[1]); } else if(s.kind === "polyline"){ s.points.forEach((pt,i)=>{ const q=worldToCanvas(pt); if(i===0) ctx.moveTo(q[0],q[1]); else ctx.lineTo(q[0],q[1]); }); }});
      ctx.stroke();
      const first = c.segments[0]; const anchor = first?.kind==="line" ? first.a : first?.points?.[0];
      if(anchor){ const t = worldToCanvas(anchor); const partNum = displayByPart.get(row.partIndex) ?? "?"; ctx.fillStyle="#fff"; ctx.font="12px Arial"; ctx.fillText(`P${partNum}-C${c.index ?? "?"}`, t[0]+4, t[1]-4); }
    });
  });
  }

  drawParts.forEach(row => {
    const b = row.bounds;
    if(!b) return;
    if(currentPart !== null && row.idx !== currentPart) return;
    const center = worldToCanvas([(b.minX + b.maxX)/2, (b.minY + b.maxY)/2]);
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.font = "bold 14px Arial";
    ctx.fillText(`Part ${row.displayIndex}`, center[0] + 6, center[1] - 6);
  });

  if(model.skeletonCuts){
    ctx.strokeStyle="#ff3333"; ctx.lineWidth=3;
    model.skeletonCuts.forEach(sc=>{ const a=worldToCanvas(sc.a), b=worldToCanvas(sc.b); ctx.beginPath(); ctx.moveTo(a[0],a[1]); ctx.lineTo(b[0],b[1]); ctx.stroke(); const mx=(a[0]+b[0])/2, my=(a[1]+b[1])/2; ctx.fillStyle="#ffaaaa"; ctx.font="12px Arial"; ctx.fillText("SK"+sc.id, mx+4, my-4);});
  }
}
cv.addEventListener("wheel", (e) => {
  if(!model) return;
  e.preventDefault();
  const rect = cv.getBoundingClientRect();
  const cx = e.clientX - rect.left;
  const cy = e.clientY - rect.top;
  const [wx, wy] = canvasToWorld(cx, cy);
  const factor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
  zoom = Math.max(0.2, Math.min(10, zoom * factor));
  const scale = baseScale * zoom;
  panX = cx - wx * scale;
  panY = (cv.height - cy) - wy * scale;
  draw();
}, { passive: false });
cv.addEventListener("mousedown", (e) => {
  if(!panMode || !model) return;
  draggingPan = true;
  dragStart = {x: e.clientX, y: e.clientY, panX, panY};
  cv.style.cursor = "grabbing";
});
window.addEventListener("mousemove", (e) => {
  if(!draggingPan || !dragStart) return;
  panX = dragStart.panX + (e.clientX - dragStart.x);
  panY = dragStart.panY - (e.clientY - dragStart.y);
  draw();
});
window.addEventListener("mouseup", () => {
  if(!draggingPan) return;
  draggingPan = false;
  dragStart = null;
  cv.style.cursor = panMode ? "grab" : "default";
});
(async function(){ model = await (await fetch(`/api/cutplan/${jobId}/model`)).json(); sortPartsTopToBottom(); initOrder(); rebuildContourOrderFromPartOrder(); renderPartsList(); renderList(); resize(); fitView(); draw(); })();
</script>
{% endblock %}
